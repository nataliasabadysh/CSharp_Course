
<p>Assembly<p> - Represents an assembly, which is a reusable, versionable, and self-describing building block of a common language runtime application.
<p>Global Assembly Cache<p> - The Global Assembly Cache (GAC) is a folder in Windows directory to store the .NET assemblies that are specifically designated to be shared by all applications executed on a system.


<h3>Types C# </h3>


    static void Main() 
    { 

        bool = true;    //  false 
        byte = 10;      //  from 0 to 255 (1 byte) System.Byte
        sbyte = -100;   //  -128 to 127  (1 byte) System.Byte 
        short  = 2;     //  -32768 to 32767 (2 byte) System.Int16 
        ushort = 2;     //  0 to 65535 (2 byte) System.Int16
        int = 1;        //  -2147483648 to 2147483647 (4 byte) System.Int32
        uint = 1;       //  0 to 4294967295 (4 byte)  System.UInt32
        long = 1000000; //  –9 223 372 036 854 775 808 to 9 223 372 036 854 775 807 (8 byte). System.Int64
        ulong = 100;    //  0 to 18 446 744 073 709 551 615  (8 byte). System.Int64

        float = 1.1;     //  ±1.5*10−45 to ±3.4*1038  (4 byte)  System.Single
        double = 1. 111; //  ±5.0*10−324 to ±1.7*10308 (8 byte). System.Double

        char = 'A';     //  Unicode (2 byte)  System.Char
        string = 'Hey'; //  Unicode, System.String
        object =        //  (4 byte) System.Object,
    }



<h3>  Variable is always defined with a data type.</h3>
<p> Variable Declaration & Initialization <p>

      int x;  
      bool isEnabled = true;
      int x;
      double y = 3.0;
      char c = 's';
      int a = 4;
      int z = a + 5; 
      string message = "Hello World!!";
      int a = 4;   // or the same Var is ->  System.Int32 b = 4;

<p>Multiple Declarations </p>

        int i, j, k, l = 0;
        int amount, num;

<p> Multi-Line Declarations </p>

        int i, j, 
        k, 
        l = 0;

<b> Variable Assignment</b>

        int i = 100;
        int j = i; // value of j will be 100

<b>❌Invalid Variable Assignment</b>

        string message = "Hello World!!";
        int i = message; // compile time error


<p> * We can tell the compiler that a literal number is not what it appears to be (ie., float instead of double, unsigned long instead of int  <p>


        float b = 30.6f;
        decimal d = 334.8m;
        var d = 1.0; // double
        var f = 1.0f; // float
        var u = 1UL; // unsigned long
        var d  = 1.0d;  // double
        var d0 = 1.0;   // double
        var d1 = 1e+3;  // double
        var d2 = 1e-3;  // double
        var f  = 1.0f;  // float
        var m  = 1.0m;  // decimal
        var i  = 1;     // int
        var ui = 1U;    // uint
        var ul = 1UL;   // ulong
        var l  = 1L;    // long


<h3>implicit typing model:  Var </h3>

        var string = "Hello World";
        var c = 20;    // =  System.Int32 
        Console.WriteLine(c.GetType().ToString());
        Console.WriteLine(string.GetType().ToString());


<p>✅ variables </p>

        int a;
        a = 20;

        var string = "Beginning in c#";
        string = null;

        var x = new { };
        var y = new { FirstName = "John", LastName = "Doe" };


<p>❌ variables </p>

        var c;
        c= 20;


        var c = null;


<h3> Implicit conversion </h3>

        int a = 4;
        int b = 6;
        byte c = a + b; // type ?  
       

<h3> Explicit conversion </h3>
        
        int a = 33;
        int b = 600;
        byte c = (byte)(a+b); // result will be convert to byte type 


<h3> Checked (with try...catch) </h3>
      

        try
        {
            int a = 33;
            int b = 600;
            byte c = checked((byte)(a + b));
            Console.WriteLine(c);
        }
          catch (OverflowException ex)
        {
          Console.WriteLine(ex.Message);
        }



<h3>  </h3>


<h3> Arithmetic operators </h3>

         
          string hello = "hello " + "world";  //  "hello world"
          int x1 = 2 + 4;                     //  6
          int x2 = 10 – 6;                    //  4
          int x3 = 10 * 6;                    //  60
          double x4 = 10.0 / 4.0;             //  2.5
          double x5 = 10.0 % 4.0;             //  2
          
          int y1 = 5;
          int z1 = ++y1;                      // z1=6; y1=6
          
          int y2 = 5;
          int z2 = y2++;                      // z2=5; y2=6
          
          int y3 = 5;
          int z3 = --y3;                      // z3=4; y3=4
         
          int y4 = 5;
          int z4 = y4--;                      // z4=5; y4=4


<h3>Boolean logical operators</h3>
         
         
          int x1 = 2; // 010
          int y1 = 5; // 101
          Console.WriteLine(x1 & y1); //  0   -> 0*1, 1*0, 0*1

          int x2 = 4; // 100
          int y2 = 5; // 101
          Console.WriteLine(x2 & y2); //  4  -> 1*1, 0*0, 0 *1

          int x1 = 2; // 010
          int y1 = 5; // 101
          Console.WriteLine(x1 | y1); // 7 – 111

          int x2 = 4; // 100
          int y2 = 5; // 101
          Console.WriteLine(x2 | y2); //  5 – 101

          int x = 9; 
          Console.WriteLine(~x);

          bool x1 = (5 > 6) || (4 < 6);       // 5 > 6 – false, 4 < 6 – true, -> true
          bool x2 = (5 > 6) || (4 > 6);       // 5 > 6 – false, 4 > 6 – false, ->false
          bool x3 = (5 > 6) && (4 < 6);       // 5 > 6 – false, 4 < 6 – true, -> false
          bool x4 = (50 > 6) && (4 / 2 < 3);  // 50 > 6 – true, 4 / 2 < 3 – true, -> true
          bool x5 = (5 > 6) ^ (4 < 6);        // 5 > 6 – false, 4 < 6 – true, поэтому -> true
          bool x6 = (50 > 6) ^ (4 / 2 < 3);   // 50 > 6 – true, 4 / 2 < 3 – true, -> false


<b> ^ Also, this operation is called XOR, it is often used for simple encryption. </b>

       
        int x = 45;                   // 1001  to -> 101101
        int key = 102;                // to -> 1100110
        int encrypt = x ^ key;        //  to -> 1001011 (or 75)
        int decrypt = encrypt ^ key;  //  to -> 45

<h1>Array </h1>
- An array is a group of like-typed variables that are referred to by a common name. And each data item is called an element of the array. 
- arrays are dynamically allocated
- we can find their length
- array variable can also be declared like other variables with [] after the data type
- index beginning from 0.
- array is an object of base type System.Array
- Array types are reference types which are derived from the abstract base type Array. These types implement IEnumerable and for it, they use foreach iteration on all arrays in c# .


<h4> Array Declaration.     Syntax :  < Data Type > [ ] < Name_Array > </h4>


          int[] nums = new int[4];
          nums[0] = 1;
          nums[1] = 2;
          nums[2] = 3;
          nums[3] = 5;
          Console.WriteLine(nums[3]);

<h4> Array Initialization.  Syntax : type [ ] < Name_Array > = new < datatype > [size]; </h4>


          int[] nums2 = new int[] { 1, 2, 3, 5 }; 


<p> or, both the same  </p>


          int[] nums3 = { 1, 2, 3, 5 };


<p> int[] nums1 = new int[] { 0, 1, 2, 3, 4, 5 }; </p>
<p> int[,] nums2 = { { 0, 1, 2 }, { 3, 4, 5 } };</p>
<p> int[,,] nums3 = new int[2, 3, 4]; </p>

          int[][] nums = new int[3][];
          nums[0] = new int[2];
          nums[1] = new int[3];
          nums[2] = new int[5];


          int[][,] nums = new int[3][,] 

          {
            new int[,] { {1,2}, {3,4} },
            new int[,] { {1,2}, {3,6} },
            new int[,] { {1,2}, {3,5}, {8, 13} } 
          };


<h3> Methods </h3>
- Length 
- Rank
- Array.Reverse
- Array.Sort


<h3> Example</h3>

            int[] nums1 = new int[] {8, 1, 5, 3, 4, 2};

            int length = nums1.Length;

            int rank = nums1.Rank;  // size of Array  -> 1

            Array.Reverse(nums1); // 2, 4, 3, 5, 1, 8

            Array.Sort(nums1); // 1, 2, 3, 4, 5, 8


<h3> if/else if/else </h3>


              int num1 = 8;
              int num2 = 6;
              
              if (num1 > num2)
              {
                Console.WriteLine("Число {0} больше числа {1}", num1, num2);
              }
              else if (num1 > num2 && num1 > 0)
              {
                Console.WriteLine("Число {0} меньше числа {1}", num1, num2);
              }
              else
              {
                Console.WriteLine("Число num1 равно числу num2");
              }


<h3> switch/case </h3>

                Console.WriteLine("Click on Y or N");
                string selection = Console.ReadLine();
                switch (selection)
                {
                  case "Y":
                      Console.WriteLine("clicked was on Y");
                      break;
                  case "N":
                      Console.WriteLine("clicked was on N");
                      break;
                  default:
                      Console.WriteLine(" no clicks ");
                      break;
                }



<h3> Ternary operation  [] ? [] : [] </h3>


            int x = 3;
            int y = 2;
            Console.WriteLine("Click on + or -");
            string selection = Console.ReadLine();
            
            int z = selection == "+" ? (x+y) : (x-y);


<h3> for  </h3>

            for (int i = 0; i < 9; i++)
            {
              Console.WriteLine(" num2 {0} = {1}", i, i * i);
            }


<p> endless cycle</p>


            int i = 0;
            for (; ;)
            {
              Console.WriteLine("Квадрат числа {0} равен {1}", ++i, i * i);
              System.Threading.Thread.Sleep(500);
            }



<h3> foreach  </h3>

              int[] array = new int[] { 1, 2, 3, 4, 5 };
              foreach (int i in array)
              {
                Console.WriteLine(i);
              }


  <p> or with for </p>


              int[] array = new int[] { 1, 2, 3, 4, 5 };
              for (int i = 0; i < array.Length; i++)
              {
                Console.WriteLine(array[i]);
              }


 <p> 🤔 * for more flexible than foreach</p>    

 - If foreach sequentially retrieves the elements of the container and is read-only, 
 - then in the for loop you can jump a few elements forward depending on the increment of the counter, and you can also change the elements:         



            int[] array = new int[] { 1, 2, 3, 4, 5 };
            for (int i = 0; i < array.Length; i++)
            {
              array[i] = array[i] * 2;
              Console.WriteLine(array[i]);
            }



<h3> do  </h3>

              int i = 6;
              do
              {
                Console.WriteLine(i);
                i--;
              }
              while (i > 0);


<h3> while  </h3>


              int i = 6;
              while (i > 0)
              {
                Console.WriteLine(i);
                i--;
              }



<h5> if is required to leave a cycle, without waiting for its end -> break;  </h5> 



              int[] array = new int[] { 1, 2, 3, 4, 12, 9 };
              
              for (int i = 0; i < array.Length; i++)
              {
                if (array[i] > 10)
                    break;
                Console.WriteLine(array[i]);
              }



<h5> just moved to the next element -> continue;  </h5> 



                  int[] array = new int[] { 1, 2, 3, 4, 12, 9 };
                  for (int i = 0; i < array.Length; i++)
                  {
                    if (array[i] > 10)
                        continue;
                    Console.WriteLine(array[i]);
                  }


<h1> Access Modifiers </h1>



                static void Method1()
                {
                  Console.WriteLine("Method1");
                }



<h3> If variables store some values </h3>

                static void Main(string[] args)
                {
                  Console.WriteLine("Привет мир!");
                }

- void - the method returns nothing




<h1> Functions  -  return a specific value.</h1>


                 static void Main(string[] args)
                      {
                        string message = Hello(); 
                        Console.WriteLine(message);
                        Sum(); 
                      }
                      static string Hello()
                      {
                        return "Hello World!";
                      }
                      static void Sum()
                      {
                        int x = 2;
                        int y = 3;
                        Console.WriteLine("{0} + {1} = {2}", x, y, x+y);
                      }


<h3> Two ways to pass parameters to a method in C #: by value and by reference </h3>
- by value, input parameters



              static int Sum(int x, int y)
              {
                return x + y;
              }

              static void Main(string[] args)   
              {
                int x = 10;    
                int z = Sum(x, 15);    
                Console.WriteLine(z);
              }



-  output parameters (+ out)

                static void Main(string[] args)
                {
                  int x = 10;
                  int area;
                  int perimetr;
                  GetData(x, 15, out area, out perimetr);
                  Console.WriteLine("Площадь: " + area);
                  Console.WriteLine("Периметр: " + perimetr); 
                }
                static void GetData(int x, int y, out int area, out int perim)
                {
                  area = x * y;
                  perim = (x + y) * 2; 
                }



<h3> Method:  GetData </h3> 
- When passing parameters by reference, the ref modifier is used before the parameters ref: 


<p> Example </p>


                      static void Main(string[] args)
                      {
                        int x = 10;
                        int y = 15;
                        Addition(ref x, y); // call method 
                        Console.WriteLine(x);
                      }
                      // method 
                      static void Addition(ref int x, int y)
                      {
                          x += y;
                      }


<p> Example </p>


                      static void Main(string[] args)
                      {  int a = 5; int b = 6;
                        Console.WriteLine(" a = {0}", a);
                        AdditionVal(a, b);
                        Console.WriteLine("a = {0}", a);
                        AdditionRef(ref a, b);
                        Console.WriteLine("a  = {0}", a); }
                      // передача по ссылке
                      static void AdditionRef(ref int x, int y)
                      {  x = x + y;
                        Console.WriteLine("x + y = {0}", x); }
                      // передача по значению
                      static void AdditionVal(int x, int y)
                      {  x = x + y;
                        Console.WriteLine("x + y = {0}", x); }


<p> Example </p>


                        static int OptionalParam(int x, int y, int z=5, int s=4)
                          {
                            return x + y + z + s;
                          }



<p> Example </p>


                          static int OptionalParam(int x, int y, int z = 5, int s = 4)
                          {
                            return x + y + z + s;
                          }
                          static void Main(string[] args)
                          {
                            OptionalParam(x: 2, y: 3); 
                            // необязательный параметр z использует значение по умолчанию
                            OptionalParam(y: 2, x: 3, s: 10);
                          }


<p> Example </p>


                          static void Addition(params int[] integers)
                          {
                            int result = 0;
                            for (int i = 0; i < integers.Length; i++)
                            {
                                result += integers[i];
                            }
                            Console.WriteLine(result);
                          } 
                          static void Main(string[] args)
                          {  Addition(1, 2, 3, 4, 5);    
                            int[] array = new int[] { 1, 2, 3, 4 };
                            Addition(array); 
                            Addition(); 
                            }



<p> Example with Array and  params</p>


                      static void Addition(params int[] integers)
                      {
                        int result = 0;
                        for (int i = 0; i < integers.Length; i++)
                        {
                            result += integers[i];
                        }
                        Console.WriteLine(result);
                      }

<p> Example with  Array</p>


                    static void AdditionMas(int[] integers, int k)
                    {
                      int result = 0;
                      for (int i = 0; i < integers.Length; i++)
                      {
                          result += (integers[i] * k);
                      }
                      Console.WriteLine(result);
                    }
                    static void Main(string[] args)
                    {
                      Addition(1, 2, 3, 4, 5);
                      int[] array = new int[] { 1, 2, 3, 4 };
                      AdditionMas(array, 2); 
                      }



<h3> Recursive function the function calls itself </h3> 



                    static int Factorial(int x)
                    {
                      if (x == 1)
                      {
                          return 1;
                      }
                      else
                      {
                          return x * Factorial(x – 1);
                      }
                    }



<p> Example Function Fibonachi  f(n) = f(n-1) + f(n-2), it be  f(0) = f(1) = 1</p>



                     static int Fibonachi(int n)
                        {
                          if (n == 0)
                          {
                              return 0;
                          }
                          if (n == 1)
                          {
                              return 1;
                          }
                          else
                          {
                              return Fibonachi(n – 1) + Fibonachi(n – 2);
                          } }



<h3> enum  (перечисление) </h3> 



                    enum days
                    {
                      monday,
                      tuesday,
                      wednesday,
                      thursday,
                      friday,
                      saturday,
                      sunday
                    }

                    enum time : byte
                    {
                      morning,
                      afternoon,
                      evening,
                      night
                    }


<p> Example by default </p>


                  enum operation
                  {  add = 0,    
                    subtract =-1,    
                    multiply =-2,    
                    divide =-3        
                  }


<p> Example </p>



                  enum operation
                  {  add = 1,     // каждый следующий элемент по умолчанию увеличивается на единицу
                    subtract,     //  2
                    multiply,     //  3
                    divide        //  4 
                  }
                  enum operation
                  { 
                    add = 2,
                    subtract = 4,
                    multiply = 8,
                    divide = 16
                  }



<p> Example  with a class </p>



                  class Program
                  {
                    enum Operation
                    {
                        add = 1,
                        subtract,
                        multiply,
                        divide
                    }

                    static void MathOp(double x, double y, Operation op)
                    {
                        double result = 0.0;
                        switch (op)
                        {
                          case Operation.add:
                              result = x + y;
                              break;
                          case Operation.subtract:
                              result = x – y;
                              break;
                          case Operation.multiply:
                              result = x * y;
                              break;
                          case Operation.divide:
                              result = x / y;
                              break;
                        } 
                        Console.WriteLine("Результат операции равен {0}", result);
                    }

                    static void Main(string[] args)
                    {
                        // Operation.add =  1
                        MathOp(10, 5, Operation.add);
                        //  Operation.multiplay = 3
                        MathOp(11, 5, Operation.divide);
                    }  
                  }



<h3> structure </h3> 


              struct Book
              {
                public string name;
                public string author;
                public int year;
                public void Info()
                {
                    Console.WriteLine("Книга '{0}' (автор {1}) была издана в {2} году", name, author, year);
                } 
              }

              static void Main(string[] args)
              {
                Book book;

                book.name = "Война и мир";
                book.author = "Л. Н. Толстой";
                book.year = 1869;  
         
                book.Info();         //Выведем информацию о книге book на экран
              }



<p> Book - it is new type data, We can also use an array of structures  </p>



              Book[] books = new Book[3];
              books[0].name = "Война и мир";
              books[0].author = "Л. Н. Толстой";
              books[0].year = 1869;

              books[1].name = "Преступление и наказание";
              books[1].author = "Ф. М. Достоевский";
              books[1].year = 1866;

              books[2].name = "Отцы и дети";
              books[2].author = "И. С. Тургенев";
              books[2].year = 1862;
              
              foreach (Book b in books)
              {
                b.Info();
              }



<p> Example  with a constructor </p>



                Book book1;
                Book book2 = new Book(); // использование конструктора
                    

<p> Example  with a constructor(method) </p>


                    
                    struct Book
                    {
                      public string name;
                      public string author;
                      public int year;    
        
                      public Book(string n, string a, int y)  // constructor
                      {
                          name = n;
                          author = a;
                          year = y;
                      }
                      public void Info()
                      {
                          Console.WriteLine("Книга '{0}' (автор {1}) была издана в {2} году", name, author, year);
                      }
                    }

                    Book book = new Book("Война и мир", "Л. Н. Толстой", 1869);
                    book.Info();




<h3> try...catch...finally </h3> 




                      static void Main(string[] args)
                      {
                        int[] a = new int[3];
                        try
                        {
                            a[5] = 4; //  Error, we have 4 elements in Array
                            Console.WriteLine("Завершение блока try");
                        }
                        catch (Exception ex)
                        {
                            Console.WriteLine("Ошибка: " + ex.Message);
                        }
                        finally
                        {
                            Console.WriteLine("Блок finally");
                        }
                      }


<p> try...catch...finally(method) </p>


                        static void Main(string[] args)
                        {
                          try
                          {
                              // блок кода
                          }
                          catch (FileNotFoundException e)
                          {
                              // обработка исключения, возникшего при отсутствии файла
                          }
                          catch (IOException e)
                          {
                              // обработка исключений ввода-вывода
                          }
                        }



<p> throw </p>


                      static void Main(string[] args)
                      {
                        try
                        {
                            string message = Console.ReadLine();
                            if (message.Length > 6)
                            {
                              throw new Exception("Length string more then 6 ");
                            }
                        }
                        catch (Exception ex)
                        {
                            Console.WriteLine("Error: " + ex.Message);
                        }
                      }



<h3> Value types and Reference types System.ValueType </h3> 
<p>Value ( Stack )</p>
- byte, sbyte, char, short, ushort, int, uint, long, ulong
- float, double
- decimal
- bool
- enum
- struct
<p>Reference (Heap)</p>
- object
- string
- class
- interface
- delegate


<p> Example </p>


              class Program
              {
                static void Test()
                {
                    State state1 = new State();           // State -Stack 
                    Country country1 = new Country();     // Country - Heap (country1)
                }
              }
              struct State
              {
                public int x;
                public int y;
              }
              class Country
              {
                public int x;
                public int y; 
              }



<p> Example </p>



              static void Test()
            {  
              State state1 = new State();       // Структура State
              State state2 = new State();

              state2.x = 1; 
              state2.y = 2;
              state1 = state2;
              state2.x = 5;         // state1.x = 1 по-прежнему
              Country country1 = new Country();       // class Country
              Country country2 = new Country();
              country2.x = 1; country2.y = 4;
              country1 = country2;
              country2.x = 7;         // теперь и country1.x = 7, так как обе ссылки и country1 и country2 указывают на один объект в Heap 
            }


<p> Example </p>


                struct State
                {
                  public int x;
                  public int y;
                  public Country country;
                }
                class Country
                {
                  public int x;
                  public int y;
                }

                class Program
                {
                static void Test()
                {
                  State state1 = new State(); 
                  State state2 = new State();        
                  state2.country = new Country();
                  state2.country.x = 5;
                  state1 = state2;
                  state2.country.x = 8; // теперь и state1.country.x = 8, так как state1.country и state2.country указывают на один объект в хипе
                } 
                }



- ✅ object d = null;
- ❌ int x = null;   - Error 
- ? - what will be get from the database Value or Null || System.Nullable<T> 
- ?? - returns the left  or rignt  operand if this operand is not != null 



                  int? z = null;
                  bool? enabled = null;

                  int? z1 = 5;
                  bool? enabled1 = null;
                  System.Double  s1 = 3.3;
                  
                  Nullable<int> z2 = 5;
                  Nullable<bool> enabled2 = null;
                  Nullable<System.Double> s2 = 3.3;

                  int? x = null;
                  int y = x ?? 100; // = 100, because x = null
 
                  int? z = 200;
                  int t = z ?? 44; // 200, because  z != null


                  int x = 44;
                  int y = x ?? 100; // Error 



<h1>Class</h1>































