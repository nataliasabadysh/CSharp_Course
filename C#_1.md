
<p>Assembly<p> - Represents an assembly, which is a reusable, versionable, and self-describing building block of a common language runtime application.
<p>Global Assembly Cache<p> - The Global Assembly Cache (GAC) is a folder in Windows directory to store the .NET assemblies that are specifically designated to be shared by all applications executed on a system.


<h3>Types C# </h3>


    static void Main() 
    { 

        bool = true;    //  false 
        byte = 10;      //  from 0 to 255 (1 byte) System.Byte
        sbyte = -100;   //  -128 to 127  (1 byte) System.Byte 
        short  = 2;     //  -32768 to 32767 (2 byte) System.Int16 
        ushort = 2;     //  0 to 65535 (2 byte) System.Int16
        int = 1;        //  -2147483648 to 2147483647 (4 byte) System.Int32
        uint = 1;       //  0 to 4294967295 (4 byte)  System.UInt32
        long = 1000000; //  –9 223 372 036 854 775 808 to 9 223 372 036 854 775 807 (8 byte). System.Int64
        ulong = 100;    //  0 to 18 446 744 073 709 551 615  (8 byte). System.Int64

        float = 1.1;     //  ±1.5*10−45 to ±3.4*1038  (4 byte)  System.Single
        double = 1. 111; //  ±5.0*10−324 to ±1.7*10308 (8 byte). System.Double

        char = 'A';     //  Unicode (2 byte)  System.Char
        string = 'Hey'; //  Unicode, System.String
        object =        //  (4 byte) System.Object,
    }



<h3>  Variable is always defined with a data type.</h3>
<p> Variable Declaration & Initialization <p>

      int x;  
      bool isEnabled = true;
      int x;
      double y = 3.0;
      char c = 's';
      int a = 4;
      int z = a + 5; 
      string message = "Hello World!!";
      int a = 4;   // or the same Var is ->  System.Int32 b = 4;

<p>Multiple Declarations </p>

        int i, j, k, l = 0;
        int amount, num;

<p> Multi-Line Declarations </p>

        int i, j, 
        k, 
        l = 0;

<b> Variable Assignment</b>

        int i = 100;
        int j = i; // value of j will be 100

<b>❌Invalid Variable Assignment</b>

        string message = "Hello World!!";
        int i = message; // compile time error


<b> const  - read: constant , "compile-time" value, and is immutable (which means it does not change over the life of the program).</b>

        const double PI = 3.14;
        const double E = 2.71;



        class MathLib
        {
          public const double PI = 3.141;
          public const double E = 2.81;
          public const double K; 
          public MathLib()
          {
              K = 2.5; // Error  – константа должна быть определена до компиляции
          }
        }

        class Program
        {
          static void Main(string[] args)
          {
              MathLib.E = 3.8; // Error – константу нельзя установить несколько раз 
          }
        }



<b> readonly </b>

                  class MathLib
                  {
                    public readonly double K; 
                    public MathLib()
                    {
                        K = 2.5; // поле для чтения может быть определено до компиляции
                    }
                  }
                  class Program
                  {
                    static void Main(string[] args)
                    {
                        MathLib.K = 3.8; // поле для чтения нельзя установить несколько раз 
                    } 
                  }



<p> * We can tell the compiler that a literal number is not what it appears to be (ie., float instead of double, unsigned long instead of int  <p>


        float b = 30.6f;
        decimal d = 334.8m;
        var d = 1.0; // double
        var f = 1.0f; // float
        var u = 1UL; // unsigned long
        var d  = 1.0d;  // double
        var d0 = 1.0;   // double
        var d1 = 1e+3;  // double
        var d2 = 1e-3;  // double
        var f  = 1.0f;  // float
        var m  = 1.0m;  // decimal
        var i  = 1;     // int
        var ui = 1U;    // uint
        var ul = 1UL;   // ulong
        var l  = 1L;    // long


<h3>implicit typing model:  Var </h3>

        var string = "Hello World";
        var c = 20;    // =  System.Int32 
        Console.WriteLine(c.GetType().ToString());
        Console.WriteLine(string.GetType().ToString());


<p>✅ variables </p>

        int a;
        a = 20;

        var string = "Beginning in c#";
        string = null;

        var x = new { };
        var y = new { FirstName = "John", LastName = "Doe" };


<p>❌ variables </p>

        var c;
        c= 20;


        var c = null;


<h3> Implicit conversion </h3>

        int a = 4;
        int b = 6;
        byte c = a + b; // type ?  
       

<h3> Explicit conversion </h3>
        
        int a = 33;
        int b = 600;
        byte c = (byte)(a+b); // result will be convert to byte type 


<h3> Checked (with try...catch) </h3>
      

        try
        {
            int a = 33;
            int b = 600;
            byte c = checked((byte)(a + b));
            Console.WriteLine(c);
        }
          catch (OverflowException ex)
        {
          Console.WriteLine(ex.Message);
        }



<h3>  </h3>


<h3> Arithmetic operators </h3>

         
          string hello = "hello " + "world";  //  "hello world"
          int x1 = 2 + 4;                     //  6
          int x2 = 10 – 6;                    //  4
          int x3 = 10 * 6;                    //  60
          double x4 = 10.0 / 4.0;             //  2.5
          double x5 = 10.0 % 4.0;             //  2
          
          int y1 = 5;
          int z1 = ++y1;                      // z1=6; y1=6
          
          int y2 = 5;
          int z2 = y2++;                      // z2=5; y2=6
          
          int y3 = 5;
          int z3 = --y3;                      // z3=4; y3=4
         
          int y4 = 5;
          int z4 = y4--;                      // z4=5; y4=4


<h3>Boolean logical operators</h3>
         
         
          int x1 = 2; // 010
          int y1 = 5; // 101
          Console.WriteLine(x1 & y1); //  0   -> 0*1, 1*0, 0*1

          int x2 = 4; // 100
          int y2 = 5; // 101
          Console.WriteLine(x2 & y2); //  4  -> 1*1, 0*0, 0 *1

          int x1 = 2; // 010
          int y1 = 5; // 101
          Console.WriteLine(x1 | y1); // 7 – 111

          int x2 = 4; // 100
          int y2 = 5; // 101
          Console.WriteLine(x2 | y2); //  5 – 101

          int x = 9; 
          Console.WriteLine(~x);

          bool x1 = (5 > 6) || (4 < 6);       // 5 > 6 – false, 4 < 6 – true, -> true
          bool x2 = (5 > 6) || (4 > 6);       // 5 > 6 – false, 4 > 6 – false, ->false
          bool x3 = (5 > 6) && (4 < 6);       // 5 > 6 – false, 4 < 6 – true, -> false
          bool x4 = (50 > 6) && (4 / 2 < 3);  // 50 > 6 – true, 4 / 2 < 3 – true, -> true
          bool x5 = (5 > 6) ^ (4 < 6);        // 5 > 6 – false, 4 < 6 – true, поэтому -> true
          bool x6 = (50 > 6) ^ (4 / 2 < 3);   // 50 > 6 – true, 4 / 2 < 3 – true, -> false


<b> ^ Also, this operation is called XOR, it is often used for simple encryption. </b>

       
        int x = 45;                   // 1001  to -> 101101
        int key = 102;                // to -> 1100110
        int encrypt = x ^ key;        //  to -> 1001011 (or 75)
        int decrypt = encrypt ^ key;  //  to -> 45

<h1>Array </h1>
- An array is a group of like-typed variables that are referred to by a common name. And each data item is called an element of the array. 
- arrays are dynamically allocated
- we can find their length
- array variable can also be declared like other variables with [] after the data type
- index beginning from 0.
- array is an object of base type System.Array
- Array types are reference types which are derived from the abstract base type Array. These types implement IEnumerable and for it, they use foreach iteration on all arrays in c# .


<h4> Array Declaration.     Syntax :  < Data Type > [ ] < Name_Array > </h4>


          int[] nums = new int[4];
          nums[0] = 1;
          nums[1] = 2;
          nums[2] = 3;
          nums[3] = 5;
          Console.WriteLine(nums[3]);

<h4> Array Initialization.  Syntax : type [ ] < Name_Array > = new < datatype > [size]; </h4>


          int[] nums2 = new int[] { 1, 2, 3, 5 }; 


<p> or, both the same  </p>


          int[] nums3 = { 1, 2, 3, 5 };


<p> int[] nums1 = new int[] { 0, 1, 2, 3, 4, 5 }; </p>
<p> int[,] nums2 = { { 0, 1, 2 }, { 3, 4, 5 } };</p>
<p> int[,,] nums3 = new int[2, 3, 4]; </p>

          int[][] nums = new int[3][];
          nums[0] = new int[2];
          nums[1] = new int[3];
          nums[2] = new int[5];


          int[][,] nums = new int[3][,] 

          {
            new int[,] { {1,2}, {3,4} },
            new int[,] { {1,2}, {3,6} },
            new int[,] { {1,2}, {3,5}, {8, 13} } 
          };


<h3> Methods </h3>
- Length 
- Rank
- Array.Reverse
- Array.Sort


<h3> Example</h3>

            int[] nums1 = new int[] {8, 1, 5, 3, 4, 2};

            int length = nums1.Length;

            int rank = nums1.Rank;  // size of Array  -> 1

            Array.Reverse(nums1); // 2, 4, 3, 5, 1, 8

            Array.Sort(nums1); // 1, 2, 3, 4, 5, 8


<h3> if/else if/else </h3>


              int num1 = 8;
              int num2 = 6;
              
              if (num1 > num2)
              {
                Console.WriteLine("Число {0} больше числа {1}", num1, num2);
              }
              else if (num1 > num2 && num1 > 0)
              {
                Console.WriteLine("Число {0} меньше числа {1}", num1, num2);
              }
              else
              {
                Console.WriteLine("Число num1 равно числу num2");
              }


<h3> switch/case </h3>

                Console.WriteLine("Click on Y or N");
                string selection = Console.ReadLine();
                switch (selection)
                {
                  case "Y":
                      Console.WriteLine("clicked was on Y");
                      break;
                  case "N":
                      Console.WriteLine("clicked was on N");
                      break;
                  default:
                      Console.WriteLine(" no clicks ");
                      break;
                }



<h3> Ternary operation  [] ? [] : [] </h3>


            int x = 3;
            int y = 2;
            Console.WriteLine("Click on + or -");
            string selection = Console.ReadLine();
            
            int z = selection == "+" ? (x+y) : (x-y);


<h3> for  </h3>

            for (int i = 0; i < 9; i++)
            {
              Console.WriteLine(" num2 {0} = {1}", i, i * i);
            }


<p> endless cycle</p>


            int i = 0;
            for (; ;)
            {
              Console.WriteLine("Квадрат числа {0} равен {1}", ++i, i * i);
              System.Threading.Thread.Sleep(500);
            }



<h3> foreach  </h3>

              int[] array = new int[] { 1, 2, 3, 4, 5 };
              foreach (int i in array)
              {
                Console.WriteLine(i);
              }


  <p> or with for </p>


              int[] array = new int[] { 1, 2, 3, 4, 5 };
              for (int i = 0; i < array.Length; i++)
              {
                Console.WriteLine(array[i]);
              }


 <p> 🤔 * for more flexible than foreach</p>    

 - If foreach sequentially retrieves the elements of the container and is read-only, 
 - then in the for loop you can jump a few elements forward depending on the increment of the counter, and you can also change the elements:         



            int[] array = new int[] { 1, 2, 3, 4, 5 };
            for (int i = 0; i < array.Length; i++)
            {
              array[i] = array[i] * 2;
              Console.WriteLine(array[i]);
            }



<h3> do  </h3>

              int i = 6;
              do
              {
                Console.WriteLine(i);
                i--;
              }
              while (i > 0);


<h3> while  </h3>


              int i = 6;
              while (i > 0)
              {
                Console.WriteLine(i);
                i--;
              }



<h5> if is required to leave a cycle, without waiting for its end -> break;  </h5> 



              int[] array = new int[] { 1, 2, 3, 4, 12, 9 };
              
              for (int i = 0; i < array.Length; i++)
              {
                if (array[i] > 10)
                    break;
                Console.WriteLine(array[i]);
              }



<h5> just moved to the next element -> continue;  </h5> 



                  int[] array = new int[] { 1, 2, 3, 4, 12, 9 };
                  for (int i = 0; i < array.Length; i++)
                  {
                    if (array[i] > 10)
                        continue;
                    Console.WriteLine(array[i]);
                  }


<h1> Access Modifiers </h1>



                static void Method1()
                {
                  Console.WriteLine("Method1");
                }



<h3> If variables store some values </h3>

                static void Main(string[] args)
                {
                  Console.WriteLine("Привет мир!");
                }

- void - the method returns nothing




<h1> Functions  -  return a specific value.</h1>


                 static void Main(string[] args)
                      {
                        string message = Hello(); 
                        Console.WriteLine(message);
                        Sum(); 
                      }
                      static string Hello()
                      {
                        return "Hello World!";
                      }
                      static void Sum()
                      {
                        int x = 2;
                        int y = 3;
                        Console.WriteLine("{0} + {1} = {2}", x, y, x+y);
                      }


<h3> Two ways to pass parameters to a method in C #: by value and by reference </h3>
- by value, input parameters



              static int Sum(int x, int y)
              {
                return x + y;
              }

              static void Main(string[] args)   
              {
                int x = 10;    
                int z = Sum(x, 15);    
                Console.WriteLine(z);
              }



-  output parameters (+ out)

                static void Main(string[] args)
                {
                  int x = 10;
                  int area;
                  int perimetr;
                  GetData(x, 15, out area, out perimetr);
                  Console.WriteLine("Площадь: " + area);
                  Console.WriteLine("Периметр: " + perimetr); 
                }
                static void GetData(int x, int y, out int area, out int perim)
                {
                  area = x * y;
                  perim = (x + y) * 2; 
                }



<h3> Method:  GetData </h3> 
- When passing parameters by reference, the ref modifier is used before the parameters ref: 


<p> Example </p>


                      static void Main(string[] args)
                      {
                        int x = 10;
                        int y = 15;
                        Addition(ref x, y); // call method 
                        Console.WriteLine(x);
                      }
                      // method 
                      static void Addition(ref int x, int y)
                      {
                          x += y;
                      }


<p> Example </p>


                      static void Main(string[] args)
                      {  int a = 5; int b = 6;
                        Console.WriteLine(" a = {0}", a);
                        AdditionVal(a, b);
                        Console.WriteLine("a = {0}", a);
                        AdditionRef(ref a, b);
                        Console.WriteLine("a  = {0}", a); }
                      // передача по ссылке
                      static void AdditionRef(ref int x, int y)
                      {  x = x + y;
                        Console.WriteLine("x + y = {0}", x); }
                      // передача по значению
                      static void AdditionVal(int x, int y)
                      {  x = x + y;
                        Console.WriteLine("x + y = {0}", x); }


<p> Example </p>


                        static int OptionalParam(int x, int y, int z=5, int s=4)
                          {
                            return x + y + z + s;
                          }



<p> Example </p>


                          static int OptionalParam(int x, int y, int z = 5, int s = 4)
                          {
                            return x + y + z + s;
                          }
                          static void Main(string[] args)
                          {
                            OptionalParam(x: 2, y: 3); 
                            // необязательный параметр z использует значение по умолчанию
                            OptionalParam(y: 2, x: 3, s: 10);
                          }


<p> Example </p>


                          static void Addition(params int[] integers)
                          {
                            int result = 0;
                            for (int i = 0; i < integers.Length; i++)
                            {
                                result += integers[i];
                            }
                            Console.WriteLine(result);
                          } 
                          static void Main(string[] args)
                          {  Addition(1, 2, 3, 4, 5);    
                            int[] array = new int[] { 1, 2, 3, 4 };
                            Addition(array); 
                            Addition(); 
                            }



<p> Example with Array and  params</p>


                      static void Addition(params int[] integers)
                      {
                        int result = 0;
                        for (int i = 0; i < integers.Length; i++)
                        {
                            result += integers[i];
                        }
                        Console.WriteLine(result);
                      }

<p> Example with  Array</p>


                    static void AdditionMas(int[] integers, int k)
                    {
                      int result = 0;
                      for (int i = 0; i < integers.Length; i++)
                      {
                          result += (integers[i] * k);
                      }
                      Console.WriteLine(result);
                    }
                    static void Main(string[] args)
                    {
                      Addition(1, 2, 3, 4, 5);
                      int[] array = new int[] { 1, 2, 3, 4 };
                      AdditionMas(array, 2); 
                      }



<h3> Recursive function the function calls itself </h3> 



                    static int Factorial(int x)
                    {
                      if (x == 1)
                      {
                          return 1;
                      }
                      else
                      {
                          return x * Factorial(x – 1);
                      }
                    }



<p> Example Function Fibonachi  f(n) = f(n-1) + f(n-2), it be  f(0) = f(1) = 1</p>



                     static int Fibonachi(int n)
                        {
                          if (n == 0)
                          {
                              return 0;
                          }
                          if (n == 1)
                          {
                              return 1;
                          }
                          else
                          {
                              return Fibonachi(n – 1) + Fibonachi(n – 2);
                          } }



<h3> enum  (перечисление) </h3> 



                    enum days
                    {
                      monday,
                      tuesday,
                      wednesday,
                      thursday,
                      friday,
                      saturday,
                      sunday
                    }

                    enum time : byte
                    {
                      morning,
                      afternoon,
                      evening,
                      night
                    }


<p> Example by default </p>


                  enum operation
                  {  add = 0,    
                    subtract =-1,    
                    multiply =-2,    
                    divide =-3        
                  }


<p> Example </p>



                  enum operation
                  {  add = 1,     // каждый следующий элемент по умолчанию увеличивается на единицу
                    subtract,     //  2
                    multiply,     //  3
                    divide        //  4 
                  }
                  enum operation
                  { 
                    add = 2,
                    subtract = 4,
                    multiply = 8,
                    divide = 16
                  }



<p> Example  with a class </p>



                  class Program
                  {
                    enum Operation
                    {
                        add = 1,
                        subtract,
                        multiply,
                        divide
                    }

                    static void MathOp(double x, double y, Operation op)
                    {
                        double result = 0.0;
                        switch (op)
                        {
                          case Operation.add:
                              result = x + y;
                              break;
                          case Operation.subtract:
                              result = x – y;
                              break;
                          case Operation.multiply:
                              result = x * y;
                              break;
                          case Operation.divide:
                              result = x / y;
                              break;
                        } 
                        Console.WriteLine("Результат операции равен {0}", result);
                    }

                    static void Main(string[] args)
                    {
                        // Operation.add =  1
                        MathOp(10, 5, Operation.add);
                        //  Operation.multiplay = 3
                        MathOp(11, 5, Operation.divide);
                    }  
                  }



<h3> structure </h3> 


              struct Book
              {
                public string name;
                public string author;
                public int year;
                public void Info()
                {
                    Console.WriteLine("Книга '{0}' (автор {1}) была издана в {2} году", name, author, year);
                } 
              }

              static void Main(string[] args)
              {
                Book book;

                book.name = "Война и мир";
                book.author = "Л. Н. Толстой";
                book.year = 1869;  
         
                book.Info();         //Выведем информацию о книге book на экран
              }



<p> Book - it is new type data, We can also use an array of structures  </p>



              Book[] books = new Book[3];
              books[0].name = "Война и мир";
              books[0].author = "Л. Н. Толстой";
              books[0].year = 1869;

              books[1].name = "Преступление и наказание";
              books[1].author = "Ф. М. Достоевский";
              books[1].year = 1866;

              books[2].name = "Отцы и дети";
              books[2].author = "И. С. Тургенев";
              books[2].year = 1862;
              
              foreach (Book b in books)
              {
                b.Info();
              }



<p> Example  with a constructor </p>



                Book book1;
                Book book2 = new Book(); // использование конструктора
                    

<p> Example  with a constructor(method) </p>


                    
                    struct Book
                    {
                      public string name;
                      public string author;
                      public int year;    
        
                      public Book(string n, string a, int y)  // constructor
                      {
                          name = n;
                          author = a;
                          year = y;
                      }
                      public void Info()
                      {
                          Console.WriteLine("Книга '{0}' (автор {1}) была издана в {2} году", name, author, year);
                      }
                    }

                    Book book = new Book("Война и мир", "Л. Н. Толстой", 1869);
                    book.Info();




<h3> try...catch...finally </h3> 




                      static void Main(string[] args)
                      {
                        int[] a = new int[3];
                        try
                        {
                            a[5] = 4; //  Error, we have 4 elements in Array
                            Console.WriteLine("Завершение блока try");
                        }
                        catch (Exception ex)
                        {
                            Console.WriteLine("Ошибка: " + ex.Message);
                        }
                        finally
                        {
                            Console.WriteLine("Блок finally");
                        }
                      }


<p> try...catch...finally(method) </p>


                        static void Main(string[] args)
                        {
                          try
                          {
                              // блок кода
                          }
                          catch (FileNotFoundException e)
                          {
                              // обработка исключения, возникшего при отсутствии файла
                          }
                          catch (IOException e)
                          {
                              // обработка исключений ввода-вывода
                          }
                        }



<p> throw </p>


                      static void Main(string[] args)
                      {
                        try
                        {
                            string message = Console.ReadLine();
                            if (message.Length > 6)
                            {
                              throw new Exception("Length string more then 6 ");
                            }
                        }
                        catch (Exception ex)
                        {
                            Console.WriteLine("Error: " + ex.Message);
                        }
                      }



<h3> Value types and Reference types System.ValueType </h3> 

<p>Value ( Stack )</p>


  - byte, sbyte, char, short, ushort, int, uint, long, ulong
  - float, double
  - decimal
  - bool
  - enum
  - struct

<p>Reference (Heap)</p>


  - object
  - string
  - class
  - interface
  - delegate


<p> Example </p>


              class Program
              {
                static void Test()
                {
                    State state1 = new State();           // State -Stack 
                    Country country1 = new Country();     // Country - Heap (country1)
                }
              }
              struct State
              {
                public int x;
                public int y;
              }
              class Country
              {
                public int x;
                public int y; 
              }



<p> Example </p>



              static void Test()
            {  
              State state1 = new State();       // Структура State
              State state2 = new State();

              state2.x = 1; 
              state2.y = 2;
              state1 = state2;
              state2.x = 5;         // state1.x = 1 по-прежнему
              Country country1 = new Country();       // class Country
              Country country2 = new Country();
              country2.x = 1; country2.y = 4;
              country1 = country2;
              country2.x = 7;         // теперь и country1.x = 7, так как обе ссылки и country1 и country2 указывают на один объект в Heap 
            }


<p> Example </p>


                struct State
                {
                  public int x;
                  public int y;
                  public Country country;
                }
                class Country
                {
                  public int x;
                  public int y;
                }

                class Program
                {
                static void Test()
                {
                  State state1 = new State(); 
                  State state2 = new State();        
                  state2.country = new Country();
                  state2.country.x = 5;
                  state1 = state2;
                  state2.country.x = 8; // теперь и state1.country.x = 8, так как state1.country и state2.country указывают на один объект в хипе
                } 
                }



- ✅ object d = null;
- ❌ int x = null;   - Error 
- ? - what will be get from the database Value or Null || System.Nullable<T> 
- ?? - returns the left  or rignt  operand if this operand is not != null 



                  int? z = null;
                  bool? enabled = null;

                  int? z1 = 5;
                  bool? enabled1 = null;
                  System.Double  s1 = 3.3;
                  
                  Nullable<int> z2 = 5;
                  Nullable<bool> enabled2 = null;
                  Nullable<System.Double> s2 = 3.3;

                  int? x = null;
                  int y = x ?? 100; // = 100, because x = null
 
                  int? z = 200;
                  int t = z ?? 44; // 200, because  z != null


                  int x = 44;
                  int y = x ?? 100; // Error 



<h1>Class</h1>


               class Book
                  {
                      public string name;
                      public string author;
                      public int year;
                      public void Info()   
                  }


<p> Constructor,  this - ref to the class </p> 


                  class Book
                  {
                    public string name;
                    public string author;
                    public int year;     
                   
                    public Book() { } 
                    public Book(string name, string author, int year)
                    {
                        this.name = name;
                        this.author = author;
                        this.year = year;
                    }     
                    public void Info()
                    


                    class Program
                    {
                      static void Main(string[] args)
                      {
                          Book b1 = new Book("Война и мир", "Л. Н. Толстой", 1869);
                          Book b1 = new Book();
                          b1.name = "Война и мир";
                          b1.author = "Л. Н. Толстой";
                          b1.year = 1869;        
                          b1.Info();


                          Book b2 = new Book { name = "Отцы и дети", author = "И. С. Тургенев", year = 1862 };
                          b2.Info();
                      }
                    }



<p> partial class - Частичные классы </p> 


                      partial class Book
                      {
                        public string name;
                        public string author;
                        public int year;
                      }

                      partial class Book
                      {
                        public void Info()
                        {
                            Console.WriteLine("Книга '{0}' (автор {1}) была издана в {2} году", name, author, year);
                        } 
                      }


<h1> public </h1>
<p>публичный, общедоступный класс или член класса. Такой член класса доступен из любого места в коде, а также из других программ и сборок</p>

<h1> private  (value by default ) </h1>
<p>закрытый класс или член класса. Представляет полную противоположность модификатору public. Такой закрытый класс или член класса доступен только из кода в том же классе или контексте</p>
<h1> protected </h1>
<p>такой член класса доступен из любого места в текущем классе или в классах-наследниках</p>
<h1> internal  (class by default ) </h1>
<p>класс и члены класса с подобным модификатором доступны из любого места кода в той же сборке, однако он недоступен для других программ и сборок (как в случае с модификатором public)</p>
<h1> protected internal </h1>
<p>совмещает функционал двух модификаторов. Классы и члены класса с таким модификатором доступны из текущей сборки и из производных классов</p>





                public class State
                {
                  int a; //  "private int a;"
                  private int b; // private - available in this particular class
                  protected int c; 
                  internal int d; 
                  protected internal int e; 
                  public int f;
                    
                  private void DisplayF()
                  {
                      Console.WriteLine("Переменная f = {0}", f);
                  } 
                  public void DisplayA()
                  {
                      Console.WriteLine("Переменная a = {0}", a);
                  }
                  internal void DisplayB()
                  {
                      Console.WriteLine("Переменная b = {0}", b);
                  }
                  protected void DisplayE()
                  {
                      Console.WriteLine("Переменная e = {0}", e);
                  }
                }


<h2> get; set; </h2>

              class Person
              {
                private string name; 
                public string Name
                {
                    get { return name;}
                    set { name = value; 
                 } 
                } 
              }

              Person p = new Person();
              p.Name = "Tom";
              string personName = p.Name;


<p>Example</p>


                class Person
                {
                  private int age; 
                  public int Age
                  {
                      set
                      {
                        if (value < 18) 
                        else age = value;
                      }
                      get { return age; } 
                  } 
                }


<p>Example</p>


                  class Person
                  {
                    private string name;   // read only
                    public string Name
                    {
                        get { return name;  }
                    } 
                    private int age;  // write only
                    public int Age
                    {
                        set { age = value; }
                    }
                  }


<p>Example,  automatic properties have been added in .NET 4.0 </p>


                    class Person
                    {
                      public string Name { get; set; }
                      public int Age { get; set; }         
                      public Person(string name, int age)
                      {
                          Name = name;
                          Age = age;
                      }
                    }


<p>Example,  overload method ui </p>


                  class UserInfo
                  {
                    public void ui(){ }
                    public void ui(string Name) { }
                    public void ui(string Name, string Family) { }
                    public void ui(string Name, string Family, byte Age)  {}

                  class Program
                  {
                    static void Main(string[] args)
                    {
                        UserInfo user1 = new UserInfo();
                        user1.ui();
                        user1.ui("Sabadysh", "Natalia", 26);
                    }
                  }



<p>Example, overload  public static </p>


                class State
                {
                  public string Name { get; set; } // название
                  public int Population { get; set; } // население
                  public double Area { get; set; } // площадь
                  
                  public static State operator +(State s1, State s2)
                  {
                      string name = s1.Name;
                      int people = s1.Population + s2.Population;
                      double area = s1.Area + s2.Area;  // возвращаем новое объединенное государство
                      
                      return new State { 
                        Name = name, 
                        Area = area, 
                        Population = people 
                      };
                  }

                  public static bool operator < (State s1, State s2)
                  {
                      if (s1.Area < s2.Area) return true;
                      else return false;
                  }
                  public static bool operator > (State s1, State s2)
                  {
                      if (s1.Area > s2.Area) return true;
                      else return false;
                  }
                }


<p>Example </p>


                static void Main(string[] args)
                {
                  State s1 = new State{ Name = "State1", Area = 300, Population = 100 };
                  State s2 = new State{ Name = "State2", Area = 200, Population = 70 };
                  
                  if (s1 > s2)
                  else if (s1 < s2)
                  else

                  State s3 = s1 + s2;
                }



<p>Example static - Ключевое слово static при определении переменной и методов указывает, что данные члены будут доступны для всего класса </p>


            class Algorithm
            {
              public static double pi = 3.14; 

              public static int Factorial(int x)
              {
                  if (x == 1) return 1;
                  else  return x * Factorial(x - 1);
              }

              public static int Fibonachi(int x)
              {
                  if (x == 0) return 1;
                  if (x == 1) return 1;
                  else return Fibonachi(x - 1) + Fibonachi(x - 2);

              }
            }

            int num1 = Algorithm.Factorial(5);
            int num2 = Algorithm.Fibonachi(5);

            Algorithm.pi = 3.14159;




<h1> inheritance  class : class (public, internal, protected и protected internal) </h1>
- we can directly inherit from only one class.


              class Person
              {
                private string firstName;
                private string lastName;     
                public string FirstName 
                {
                    get { return firstName; }
                    set { firstName = value; }
                }
                public string LastName 
                {
                    get { return lastName; }
                    set { lastName = value; }
                }
                public void Display()
              }
              

              class Employee : Person
              {
                public void Display()
                {  
                  Console.WriteLine(FirstName); 
                }
                }
              }



- virtual - override / sealed 


        class Person
        {
          public string FirstName { get; set; }
          public string LastName { get; set; } 
          public virtual void Display() {  Console.WriteLine(FirstName + " " + LastName);  }
          public sealed void Display2(){Console.WriteLine(FirstName + " " + LastName); } }

        }

        class Employee : Person
        {
            public string Company { get; set; }
            public override void Display()  {  Console.WriteLine(FirstName + " " + LastName + " works in " + Company); }
        }



<p>Example with constructor  </p>



            class Person
            {
            public string FirstName { get;  set; }
            public string LastName { get; set; } 
            public Person(string FirstName, string LastName)
            {
              this.FirstName = FirstName ;
              this.LastName = LastName;
            } 
            public virtual void Display() { Console.WriteLine(FirstName + " " + LastName);  }
            }

            class Employee : Person
            {
            public string Company { get; set; } 
            public Employee(string FirstName, string LastName, string Company ) : base(FirstName, LastName)
            {
              this.Company = Company ;
            }
            public override void Display()
            {
              base.Display();
              Console.WriteLine("Место работы: " + Company);
            }
            }



<h1>interface  (IComparable, IEnumerable) </h1>
- Interfaces allow you to define some functionality that has no specific implementation, which is then implemented by the classes that use these interfaces.


            interface IAccount
            {
              int CurrentSum { get; set; }
              void Put(int sum);
              void Withdraw(int sum);
              int Percentage { get; set; }
            }

            class Client : IAccount
            {
              // .. 
            }

            class Client : Person, IAccount
            {
              int sum;  // store sum
              int percentage;   // store percentage
              public string Bank { get; set; } 
              
              public Client(string FirstName, string LastName, string Bank, int sum, int percentage) : base(FirstName, LastName)
              {
                  this.Bank = Bank;
                  this.sum = sum;
                  this.percentage = percentage;
              }
                 public override void Display()
              {  Console.WriteLine(FirstName + " " + LastName + " has an account in bank " +  Bank + " of sum " + sum);  }

              public int CurrentSum{ get { return sum; } }
              public void Put(int sum){ sum += sum;}
              public void Withdraw(int sum){ if (sum <= sum) sum -= sum;} 
              public int Percentage{ get { return percentage; }
               }
            }

            interface IDepositAccount : IAccount
              {
                void GetIncome(); 
              }



<h1> System.Object </h1> 

Methodas 
 - ToString() - get a string representation of this object   ( override)
 - GetHashCode() 
 - GetType()  - to  get type  of obj  (typepf)
 - Equals() - allows you to compare two objects for equality:

<p>Example ToString()  </p>



              class Human
              {
                public string Name { get; set; }
                public override string ToString()
                
                {
                    return Name;
                }
              }
              class Animal { }

              class Program
              {
                static void Main(string[] args)
                { 
                    Human human = new Human();
                    human.Name = "Вова";
                    Animal anim = new Animal();
                }
              }



<p>Example GetHashCode()  </p>


                      static void Main(string[] args)
                      {
                        string str1 = "Hello World!";
                        string str2 = "Hello World!";
                        string str3 = "Hello!";
                        Console.WriteLine(str1.GetHashCode());
                        Console.WriteLine(str2.GetHashCode());
                        Console.WriteLine(str3.GetHashCode());
                        Console.WriteLine(str1.GetHashCode() == str2.GetHashCode());
                        Console.WriteLine(str1.GetHashCode() == str3.GetHashCode());
                      }


<p>Example GetType()   </p>


                      Animal anim = new Animal();
                      Console.WriteLine(anim.GetType());

                      Person[] persons = new Person[] { 
                        new Client("Tom", "Johnes", "SberBank", 200, 20), new Employee("Bill", "Gates", "Microsoft")
                        };
                      foreach (Person p in persons){  if (p.GetType() == typeof(Client)) Console.WriteLine("Это объект класса Client"); }


<p>Example Equals()    </p>


                    class Human
                    {
                      public string Name { get; set; } 
                      public override bool Equals(object obj)
                      {
                          if (obj.GetType() != this.GetType()) 
                          {
                            return false;
                          }
                          Human human2 = (Human)obj;
                          return (this.Name == human2.Name);
                      }
                    }


<p>Example </p>


                    interface IAccount
                  {
                    int CurrentSum { get; }
                    void Put(int sum);
                    void Withdraw(int sum);
                    int Percentage { get; }
                  }


                  abstract class Person 
                  {
                    public string FirstName { get;  set; }
                    public string LastName { get; set; } 
                    public Person(string FirstName, string LastName)
                    {
                        this.FirstName = FirstName;
                        this.LastName = LastName;
                    } 
                    public abstract void Display();
                  }


                  class Employee : Person
                  {
                    public string Company { get; set; } 
                    public Employee(string FirstName, string LastName, string Company) : base(FirstName, LastName)
                    {
                        this.Company = Company;
                    }
                    public override void Display()
                    {   Console.WriteLine(FirstName + " " + LastName + " works in " + Company);  }
                  }
                  
                  
                  class Client : Person, IAccount
                  {
                    int sum; 
                    int percentage; 
                    public string Bank { get; set; }
                    public Client(string FirstName, string LastName, string Bank, int sum, int percentage) : base(FirstName, LastName)
                    {
                        this.Bank = Bank;
                        this.sum = sum;
                        this.percentage = percentage;
                    }
                    public override void Display()
                    {
                        Console.WriteLine(FirstName + " " + LastName + " has an account in bank" + Bank + " of sum " + sum.ToString());
                    }
                    public int CurrentSum {  get { return sum; } }
                    public void Put(int sum) {  this.sum += sum; }
                    public void Withdraw(int sum){ if (sum >= this.sum) this.sum -= sum; }
                    public int Percentage   {  get { return percentage; } }
                  }

                  object emp = new Employee("John", "Gates", "ITCompany");
                  Person cl = new Client("Tom", "Johnes", "ITBank", 200, 20);
                  ((Employee)emp).Display();
                  cl.Display(); 
                  string bank = ((Client)cl).Bank;


-Obj 
- Employee
- Person 
- Client



















